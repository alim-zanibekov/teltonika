// Copyright 2022 Alim Zanibekov
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

package teltonika

import (
	"bytes"
	"encoding/hex"
	"math/rand"
	"strings"
	"testing"
	"time"
)

func TestCodec12Encode(t *testing.T) {
	buffer, err := EncodePacket(&Packet{
		CodecID:  Codec12,
		Data:     nil,
		Messages: []Message{{Type: TypeCommand, Text: "getinfo"}},
	})
	if err != nil {
		t.Fatal(err)
	}

	encoded := hex.EncodeToString(buffer)
	expected := strings.ToLower("000000000000000F0C010500000007676574696E666F0100004312")

	if encoded != expected {
		t.Error("encoded: ", encoded)
		t.Error("expected:", expected)
	}
}

func TestCodec13Encode(t *testing.T) {
	buffer, err := EncodePacket(&Packet{
		CodecID:  Codec13,
		Data:     nil,
		Messages: []Message{{Type: TypeCommand, Text: "getinfo", Timestamp: 176276256}},
	})
	if err != nil {
		t.Fatal(err)
	}

	encoded := hex.EncodeToString(buffer)
	expected := strings.ToLower("00000000000000130d01050000000b0a81c320676574696e666f010000ed9b")

	if encoded != expected {
		t.Error("encoded: ", encoded)
		t.Error("expected:", expected)
	}
}

func TestCodec14Encode(t *testing.T) {
	buffer, err := EncodePacket(&Packet{
		CodecID:  Codec14,
		Data:     nil,
		Messages: []Message{{Type: TypeCommand, Text: "getver", Imei: "352093081452251"}},
	})
	if err != nil {
		t.Fatal(err)
	}

	encoded := hex.EncodeToString(buffer)
	expected := strings.ToLower("00000000000000160E01050000000E0352093081452251676574766572010000D2C1")

	if encoded != expected {
		t.Error("encoded: ", encoded)
		t.Error("expected:", expected)
	}
}

func TestTCPCodecsDecodeWithoutErrors(t *testing.T) {
	cases := []string{
		"000000000000003608010000016B40D8EA30010000000000000000000000000000000105021503010101425E0F01F10000601A014E0000000000000000010000C7CF",
		"000000000000002808010000016B40D9AD80010000000000000000000000000000000103021503010101425E100000010000F22A",
		"000000000000004308020000016B40D57B480100000000000000000000000000000001010101000000000000016B40D5C198010000000000000000000000000000000101010101000000020000252C",
		"000000000000005F10020000016BDBC7833000000000000000000000000000000000000B05040200010000030002000B00270042563A00000000016BDBC7871800000000000000000000000000000000000B05040200010000030002000B00260042563A00000200005FB3",
		"000000000000004A8E010000016B412CEE000100000000000000000000000000000000010005000100010100010011001D00010010015E2C880002000B000000003544C87A000E000000001DD7E06A00000100002994",
		"00000000000000A98E020000017357633410000F0DC39B2095964A00AC00F80B00000000000B000500F00100150400C800004501007156000500B5000500B600040018000000430FE00044011B000100F10000601B000000000000017357633BE1000F0DC39B2095964A00AC00F80B000001810001000000000000000000010181002D11213102030405060708090A0B0C0D0E0F104545010ABC212102030405060708090A0B0C0D0E0F10020B010AAD020000BF30",
	}

	for _, s := range cases {
		buf, _ := hex.DecodeString(s)
		size, _, err := DecodeTCPFromSlice(buf)
		if err != nil {
			t.Fatal(err)
		}
		if size != len(buf) {
			t.Error("[DecodeTCPFromSlice] payload not fully processed")
		}
	}

	for _, s := range cases {
		buf, _ := hex.DecodeString(s)
		reader := bytes.NewReader(buf)
		read, _, err := DecodeTCPFromReader(reader)
		if err != nil {
			t.Fatal(err)
		}
		if reader.Len() != 0 {
			t.Error("[DecodeTCPFromReader] payload not fully processed")
		}
		if hex.Dump(read) != hex.Dump(buf) {
			t.Error("[DecodeTCPFromReader] read bytes buffer invalid")
		}
	}

	for _, s := range cases {
		buf, _ := hex.DecodeString(s)
		reader := bytes.NewReader(buf)
		output := make([]byte, 1300)
		n, _, err := DecodeTCPFromReaderBuf(reader, output)
		if err != nil {
			t.Fatal(err)
		}
		if reader.Len() != 0 {
			t.Error("[DecodeTCPFromReaderBuf] payload not fully processed")
		}
		if hex.Dump(output[:n]) != hex.Dump(buf) {
			t.Error("[DecodeTCPFromReaderBuf] read bytes buffer invalid")
		}
	}
}

func TestTCPCodecsDecodeMustFail(t *testing.T) {
	cases := []string{
		"000001000000003608010000016B40D8EA30010000000000000000000000000000000105021503010101425E0F01F10000601A014E0000000000000000010000C7C1",
		"000000000000003608010000016B40D8EA30010000000000000000000000000000000105021503010101425E0F01F10000601A014E0000000000000000050000C7C1",
		"000000000000003608010000016B40D8EA30010000000000000000000000000000000105021503010101425E0F01F10000601A014E0000000000000000010000C7C1",
		"000000000000002808010000016B40D9AD80010000000000000000000000000000000103021503010101425E100000010000F23A",
		"000000000000003604010000001B40D8EA30010000000000000000000000000000000105021503010101425E0F01F10000601A014E0000000000000000050000C7C1",
		"000000000000003611010000019B40D8EA30010000000000000000000000000000000105021503010101425E0F01F10000601A014E0000000000000000050000C7C1",
		"000000000000004308020000016B40D57B480100000000000000000000000000000001010101000000000000016B40D5C198010000000000000000000000000000000101010101000000020000254C",
		"000000000000005F10020000016BDBC7833000000000000000000000000000000000000B05040200010000030002000B00270042563A00000000016BDBC7871800000000000000000000000000000000000B05040200010000030002000B00260042563A00000200005F13",
		"000000000000004A8E010000016B412CEE000100000000000000000000000000000000010005000100010100010011001D00010010015E2C880002000B000000003544C87A000E000000001DD7E06A00000100002991",
		"00000000000000A98E020000017357633410000F0DC39B2095964A00AC00F80B00000000000B000500F00100150400C800004501007156000500B5000500B600040018000000430FE00044011B000100F10000601B000000000000017357633BE1000F0DC39B2095964A00AC00F80B000001810001000000000000000000010181002D11213102030405060708090A0B0C0D0E0F104545010ABC212102030405060708090A0B0C0D0E0F10020B010AAD020000BF40",
	}

	for _, s := range cases {
		buf, _ := hex.DecodeString(s)
		_, _, err := DecodeTCPFromSlice(buf)
		if err == nil {
			t.Error("[DecodeTCPFromSlice] invalid payload processed successfully")
		}
	}
}

func TestUDPCodecsDecodeWithoutErrors(t *testing.T) {
	cases := []string{
		"005FCAFE0107000F3335323039333038363430333635358E010000016B4F831C680100000000000000000000000000000000010005000100010100010011009D00010010015E2C880002000B000000003544C87A000E000000001DD7E06A000001",
		"003DCAFE0105000F33353230393330383634303336353508010000016B4F815B30010000000000000000000000000000000103021503010101425DBC000001",
		"0086CAFE0101000F3335323039333038353639383230368E0100000167EFA919800200000000000000000000000000000000FC0013000800EF0000F00000150500C80000450200010000710000FC00000900B5000000B600000042305600CD432A00CE6064001100090012FF22001303D1000F0000000200F1000059D90010000000000000000001",
		"0083CAFE0101000F3335323039333038353639383230368E0100000167F1AEEC00000A750E8F1D43443100F800B210000000000012000700EF0000F00000150500C800004501000100007142000900B5000600B6000500422FB300CD432A00CE60640011000700120007001303EC000F0000000200F1000059D90010000000000000000001",
		"01E4CAFE0126000F333532303934303839333937343634080400000163C803B420010A259E1A1D4A057D00DA0128130057421B0A4503F00150051503EF01510052005900BE00C1000AB50008B60005427025CD79D8CE605A5400005500007300005A0000C0000007C700000018F1000059D910002D32C85300000000570000000064000000F7BF000000000000000163C803AC50010A25A9D21D4A01B600DB0128130056421B0A4503F00150051503EF01510052005900BE00C1000AB50008B6000542702ECD79D8CE605A5400005500007300005A0000C0000007C700000017F1000059D910002D32B05300000000570000000064000000F7BF000000000000000163C803A868010A25B5581D49FE5400DB0127130057421B0A4503F00150051503EF01510052005900BE00C1000AB50008B60005427039CD79D8CE605A5400005500007300005A0000C0000007C700000017F1000059D910002D32995300000000570000000064000000F7BF000000000000000163C803A4B2010A25CC861D49F75C00DB0124130058421B0A4503F00150051503EF01510052005900BE00C1000AB50008B6000542703CCD79D8CE605A5400005500007300005A0000C0000007C700000018F1000059D910002D32695300000000570000000064000000F7BF000000000004",
	}

	for _, s := range cases {
		buf, _ := hex.DecodeString(s)
		size, _, err := DecodeUDPFromSlice(buf)
		if err != nil {
			t.Fatal(err)
		}
		if size != len(buf) {
			t.Error("[DecodeUDPFromSlice] payload not fully processed")
		}
	}

	for _, s := range cases {
		buf, _ := hex.DecodeString(s)
		reader := bytes.NewReader(buf)
		read, _, err := DecodeUDPFromReader(reader)
		if err != nil {
			t.Fatal(err)
		}
		if reader.Len() != 0 {
			t.Error("[DecodeUDPFromReader] payload not fully processed")
		}
		if hex.Dump(read) != hex.Dump(buf) {
			t.Error("[DecodeUDPFromReader] read bytes buffer invalid")
		}
	}

	for _, s := range cases {
		buf, _ := hex.DecodeString(s)
		reader := bytes.NewReader(buf)
		output := make([]byte, 1300)
		n, _, err := DecodeUDPFromReaderBuf(reader, output)
		if err != nil {
			t.Fatal(err)
		}
		if reader.Len() != 0 {
			t.Error("[DecodeUDPFromReaderBuf] payload not fully processed")
		}
		if hex.Dump(output[:n]) != hex.Dump(buf) {
			t.Error("[DecodeUDPFromReaderBuf] read bytes buffer invalid")
		}
	}
}

func TestUDPCodecsDecodeMustFail(t *testing.T) {
	cases := []string{
		"005FCAFE010700043335323039333038363430333635358E010000016B4F831C680100000000000000000000000000000000010005000100010100010011009D00010010015E2C880002000B000000003544C87A000E000000001DD7E06A000001",
		"013DCAFE0105000F33353230393330383634303336353508010000016B4F815B30010000000000000000000000000000000103021503010101425DBC000001",
		"015BCAFE0101000F33353230393430383532333135393210070000015117E40FE80000000000000000000000000000000000EF05050400010000030000B40000EF01010042111A000001",
	}

	for _, s := range cases {
		buf, _ := hex.DecodeString(s)
		_, _, err := DecodeUDPFromSlice(buf)
		if err == nil {
			t.Error("[DecodeUDPFromSlice] invalid payload processed successfully")
		}
	}
}

func TestCodecsDecodeCommandResponseWithoutErrors(t *testing.T) {
	cases := []string{
		"00000000000000900C010600000088494E493A323031392F372F323220373A3232205254433A323031392F372F323220373A3533205253543A32204552523A312053523A302042523A302043463A302046473A3020464C3A302054553A302F302055543A3020534D533A30204E4F4750533A303A3330204750533A31205341543A302052533A332052463A36352053463A31204D443A30010000C78F",
		"00000000000000370C01060000002F4449313A31204449323A30204449333A302041494E313A302041494E323A313639323420444F313A3020444F323A3101000066E3",
		"00000000000000AB0E0106000000A303520930814522515665723A30332E31382E31345F3034204750533A41584E5F352E31305F333333332048773A464D42313230204D6F643A313520494D45493A33353230393330383134353232353120496E69743A323031382D31312D323220373A313320557074696D653A3137323334204D41433A363042444430303136323631205350433A312830292041584C3A30204F42443A3020424C3A312E362042543A340100007AAE",
	}

	for _, s := range cases {
		buf, _ := hex.DecodeString(s)
		size, _, err := DecodeTCPFromSlice(buf)
		if err != nil {
			t.Fatal(err)
		}
		if size != len(buf) {
			t.Error("[DecodeTCPFromSlice] payload not fully processed")
		}
	}

	for _, s := range cases {
		buf, _ := hex.DecodeString(s)
		reader := bytes.NewReader(buf)
		read, _, err := DecodeTCPFromReader(reader)
		if err != nil {
			t.Fatal(err)
		}
		if reader.Len() != 0 {
			t.Error("[DecodeTCPFromReader] payload not fully processed")
		}
		if hex.Dump(read) != hex.Dump(buf) {
			t.Error("[DecodeTCPFromReader] read bytes buffer invalid")
		}
	}
}

func BenchmarkTCPDecode(b *testing.B) {
	cases := []string{
		"000000000000003608010000016B40D8EA30010000000000000000000000000000000105021503010101425E0F01F10000601A014E0000000000000000010000C7CF",
		"000000000000002808010000016B40D9AD80010000000000000000000000000000000103021503010101425E100000010000F22A",
		"000000000000004308020000016B40D57B480100000000000000000000000000000001010101000000000000016B40D5C198010000000000000000000000000000000101010101000000020000252C",
		"000000000000005F10020000016BDBC7833000000000000000000000000000000000000B05040200010000030002000B00270042563A00000000016BDBC7871800000000000000000000000000000000000B05040200010000030002000B00260042563A00000200005FB3",
		"000000000000004A8E010000016B412CEE000100000000000000000000000000000000010005000100010100010011001D00010010015E2C880002000B000000003544C87A000E000000001DD7E06A00000100002994",
		"00000000000000A98E020000017357633410000F0DC39B2095964A00AC00F80B00000000000B000500F00100150400C800004501007156000500B5000500B600040018000000430FE00044011B000100F10000601B000000000000017357633BE1000F0DC39B2095964A00AC00F80B000001810001000000000000000000010181002D11213102030405060708090A0B0C0D0E0F104545010ABC212102030405060708090A0B0C0D0E0F10020B010AAD020000BF30",
	}

	casesBin := make([][]byte, len(cases))

	for i := range cases {
		bs, _ := hex.DecodeString(cases[i])
		casesBin[i] = bs
	}

	benchCase := make([][]byte, b.N)

	for i := 0; i < b.N; i++ {
		benchCase[i] = casesBin[rand.Intn(len(cases))]
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		_, _, err := DecodeTCPFromSlice(benchCase[i])
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkUDPDecode(b *testing.B) {
	cases := []string{
		"005FCAFE0107000F3335323039333038363430333635358E010000016B4F831C680100000000000000000000000000000000010005000100010100010011009D00010010015E2C880002000B000000003544C87A000E000000001DD7E06A000001",
		"003DCAFE0105000F33353230393330383634303336353508010000016B4F815B30010000000000000000000000000000000103021503010101425DBC000001",
		"0086CAFE0101000F3335323039333038353639383230368E0100000167EFA919800200000000000000000000000000000000FC0013000800EF0000F00000150500C80000450200010000710000FC00000900B5000000B600000042305600CD432A00CE6064001100090012FF22001303D1000F0000000200F1000059D90010000000000000000001",
		"0083CAFE0101000F3335323039333038353639383230368E0100000167F1AEEC00000A750E8F1D43443100F800B210000000000012000700EF0000F00000150500C800004501000100007142000900B5000600B6000500422FB300CD432A00CE60640011000700120007001303EC000F0000000200F1000059D90010000000000000000001",
		"01E4CAFE0126000F333532303934303839333937343634080400000163C803B420010A259E1A1D4A057D00DA0128130057421B0A4503F00150051503EF01510052005900BE00C1000AB50008B60005427025CD79D8CE605A5400005500007300005A0000C0000007C700000018F1000059D910002D32C85300000000570000000064000000F7BF000000000000000163C803AC50010A25A9D21D4A01B600DB0128130056421B0A4503F00150051503EF01510052005900BE00C1000AB50008B6000542702ECD79D8CE605A5400005500007300005A0000C0000007C700000017F1000059D910002D32B05300000000570000000064000000F7BF000000000000000163C803A868010A25B5581D49FE5400DB0127130057421B0A4503F00150051503EF01510052005900BE00C1000AB50008B60005427039CD79D8CE605A5400005500007300005A0000C0000007C700000017F1000059D910002D32995300000000570000000064000000F7BF000000000000000163C803A4B2010A25CC861D49F75C00DB0124130058421B0A4503F00150051503EF01510052005900BE00C1000AB50008B6000542703CCD79D8CE605A5400005500007300005A0000C0000007C700000018F1000059D910002D32695300000000570000000064000000F7BF000000000004",
	}

	casesBin := make([][]byte, len(cases))

	for i := range cases {
		bs, _ := hex.DecodeString(cases[i])
		casesBin[i] = bs
	}

	benchCase := make([][]byte, b.N)

	for i := 0; i < b.N; i++ {
		benchCase[i] = casesBin[rand.Intn(len(cases))]
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		_, _, err := DecodeUDPFromSlice(benchCase[i])
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkEncode(b *testing.B) {
	cases := []*Packet{
		{
			CodecID:  Codec12,
			Data:     nil,
			Messages: []Message{{Type: TypeCommand, Text: "getinfo"}},
		},
		{
			CodecID:  Codec12,
			Data:     nil,
			Messages: []Message{{Type: TypeCommand, Text: "getio"}},
		},
		{
			CodecID:  Codec12,
			Data:     nil,
			Messages: []Message{{Type: TypeCommand, Text: "getver"}},
		},
		{
			CodecID:  Codec13,
			Data:     nil,
			Messages: []Message{{Type: TypeCommand, Text: "getver", Timestamp: uint32(time.Now().Unix())}},
		},
		{
			CodecID:  Codec13,
			Data:     nil,
			Messages: []Message{{Type: TypeCommand, Text: "getinfo", Timestamp: uint32(time.Now().Unix())}},
		},
		{
			CodecID:  Codec14,
			Data:     nil,
			Messages: []Message{{Type: TypeCommand, Text: "getver", Imei: "352093081452251"}},
		},
		{
			CodecID:  Codec14,
			Data:     nil,
			Messages: []Message{{Type: TypeCommand, Text: "getio", Imei: "352093081452251"}},
		},
	}

	benchCase := make([]*Packet, b.N)

	for i := 0; i < b.N; i++ {
		benchCase[i] = cases[rand.Intn(len(cases))]
	}

	b.ResetTimer()

	for i := 0; i < b.N; i++ {
		_, err := EncodePacket(benchCase[i])
		if err != nil {
			b.Fatal(err)
		}
	}
}
